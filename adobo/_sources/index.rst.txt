Welcome to adobo's documentation!
#################################

What adobo is
*************
adobo is an analysis framework for single cell RNA sequencing data (scRNA-seq) and enables exploratory analysis through a set of Python modules. adobo can be used to compose scripts, used in interactive workflows and much more. The goal of adobo is to consolidate single cell computational analysis methods in the Python programming language.

Contact developer and maintainer
********************************
adobo is developed by Oscar Franz√©n at Karolinska Institutet. Limited support is available over e-mail: p.oscar.franzen@gmail.com or oscar.franzen@ki.se

Notes on this tutorial
======================
Some basic knowledge of Python, `NumPy <https://en.wikipedia.org/wiki/NumPy>`_ and `pandas <https://en.wikipedia.org/wiki/Pandas_(software)>`_ and their commonly used data structures is assumed. Furthermore, most of adobo's functions have parameters with sensible defaults so that many parameters don't need to be specified upon calling a specific function, but for clarity the most important parameters are shown in the examples. We refer to the adobo package as 'ad'.

Installation
============
First step is to install adobo. The recommended way to install adobo is to first clone the GitHub repository and then use ``pip3`` from your terminal, which will also install necessary dependencies (instead of using git one can also navigate to the `repository <https://github.com/oscar-franzen/adobo/>`_ and press the download button):

.. code-block:: bash

   $ git clone https://github.com/oscar-franzen/adobo.git
   
   $ cd adobo
   
   # local installation
   $ pip3 install --user .
   
   # below installs adobo without package dependencies (not recommended)
   $ pip3 install --user --no-deps .

.. note::

   Support for ``PyPI`` is on the TODO list.

.. note::

   adobo is developed and tested on Python version 3.6.x; older versions may work but are untested.

After installing it, you can now delete the cloned repository and test that everything works by firing up your Python 3 interpreter:

.. code-block:: bash

   $ python3

Try importing the library and it should greet you with the current version and the URL to the documentation (this page):

>>> import adobo as ad
adobo version 0.1. Documentation: https://oscar-franzen.github.io/adobo/

Package organization
====================
adobo is organized into several modules containing related functions. All module and function names are lowercase to make them easier to remember.

.. list-table::
   :header-rows: 1
   
   * - Module name
     - Meaning
   * - ``preproc``
     - data preprocessing
   * - ``data``
     - the dataset container class
   * - ``dr``
     - dimensional reduction techniques
   * - ``hvg``
     - highly variable gene discovery
   * - ``normalize``
     - normalization of raw read counts
   * - ``IO``
     - reading and writing data (input/output)
   * - ``clustering``
     - functions related to data clustering operations
   * - ``de``
     - differential expression between cell clusters
   * - ``plotting``
     - data visualization
   * - ``bio``
     - functions related to biology, for example cell cycle prediction
   * - ``stats``
     - miscellaneous or general statistical functions that don't fit anywhere else

Internal modules
^^^^^^^^^^^^^^^^
These do not need to be accessed but are listed here for documentation purposes.

.. list-table::
   :header-rows: 1

   * - Module name
     - Function content
   * - ``_colors``
     - related to color generation
   * - ``_log``
     - internal utilities
   * - ``_constants``
     - internal constants

Getting started and pre-processing your data
============================================
Loading the package
^^^^^^^^^^^^^^^^^^^
The first step is to load the adobo package by importing it:

.. code-block:: python3

   import adobo as ad

.. note::
   Debug information in the form of traceback output is suppressed by default. However, this information is often useful when trying to solve program bugs. To enable full traceback set:
   
   ``ad.debug=1``

Loading your data from a text file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First we need to create a new adobo object, which is an instance of the class :py:class:`adobo.data.dataset`. This will be a new object containing your single cell data, meta data and analysis results. The input file should be a gene expression matrix (rows as genes and cells as columns) in plain text format. Fields can be separated by any character and it can be changed with the ``sep`` parameter. ``sep`` can be a single character or a regular expression (default is the regular expression ``\s``). The data matrix file can have a header or not (``header=0`` indicates a header is present, otherwise use ``header=None``). If the header of your gene expression matrix contains a label for gene symbols, set ``column_id='yes'`` or simply ``column_id='auto'`` to autodetect this. :py:func:`adobo.IO.load_from_file` calls `pandas.DataFrame.read_csv <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html>`_ and any additional parameters are passed on into this method. The function :py:func:`adobo.IO.load_from_file` is used to load data from a raw read counts matrix and the returned object is an instance of :class:`adobo.data.dataset`:

.. code-block:: python3

   exp = ad.IO.load_from_file('GSE95315.tab',
                              column_id='auto',
                              desc='mouse brain data')

The raw read counts matrix is stored in the attribute ``count_data`` inside the dataset object (:py:attr:`adobo.data.dataset.count_data`). Here we use data from `GEO95315 <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE95315>`_, which can be `downloaded here <https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE95315&format=file&file=GSE95315%5F10X%5Fexpression%5Fdata%2Etab%2Egz>`_.

``desc`` can be used to specify an arbitrary string describing the data, but it can also be left empty.

.. important::

   The loaded data must **not** be normalized, i.e. it should be raw read counts.

.. note::

   All downstream operations and analyses are performed and stored as attributes in the adobo object, i.e. functions are applied on this object.

.. note::

   Many adobo functions also have a ``verbose`` parameter, which when ``True`` makes the function more informative.

Loading compressed data
^^^^^^^^^^^^^^^^^^^^^^^
scRNA-seq is zero inflated, and therefore compress strongly. We can load the compressed data directly without having to uncompress it first; the compression format is detected automatically (``gzip``, ``bz2``, ``zip`` and ``xz`` are supported). For example:

.. code-block:: python3

   exp = ad.IO.load_from_file('GSE95315.tab.gz',
                              column_id='auto')

Your gene expression data is stored in the attribute ``exp.count_data``, and after loading it is good practise to examine that the data were loaded properly:

>>> exp
53,889 genes and 384 cells were loaded

Creating the data class object directly from a pandas data frame
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
In many cases we already have our data in a data frame, in those cases we can just create the container object directly:

.. code-block:: python3
 
   # where 'df' is the data frame, columns are cells and rows are genes
   exp = ad.dataset(df)

Saving object
^^^^^^^^^^^^^
It is convenient not having to repeat analyses once they are finished. Saving an object to disk can be done via the ``joblib`` package (`complete joblib docs <https://joblib.readthedocs.io/en/latest/>`_; Python's standard `pickle <https://docs.python.org/3/library/pickle.html>`_ is another option):

.. code-block:: python3

   import joblib
   
   # compress=0 will turn off data compression
   joblib.dump(exp, 'test.joblib', compress=3)
   
   exp = joblib.load('test.joblib')

Instead of writing three lines of code and always remembering the name of the output file, we can specify ``output_file`` in :py:func:`adobo.IO.load_from_file` and then calling :py:func:`adobo.data.dataset.save()`.

Accessing meta data for cells and genes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Meta data are stored in the adobo object (an instance of :py:class:`adobo.data.dataset`). Two data structures (instances of :class:`pandas.DataFrame`) hold meta data for cells and genes, respectively:

>>> exp.meta_cells
                      total_reads status  detected_genes   mito  ERCC  rRNA
EXP1_COL01_ROW01_S1          5935     OK             426   1455     2     0
EXP1_COL01_ROW02_S1          3036     OK             464   1583     0     0
EXP1_COL01_ROW03_S1         38477     OK            1961  20935     7     4
EXP1_COL01_ROW04_S1         63962     OK            3478   4463     7     0
EXP1_COL01_ROW05_S1          1885     OK             993    127     0     0
...                           ...    ...             ...    ...   ...   ...
EXP1_COL20_ROW36_S20        43051     OK            3277   4975    29     0
EXP1_COL20_ROW37_S20       162617     OK            4224  54144    55     0
EXP1_COL20_ROW38_S20        56649     OK            3281   4223    31     0
EXP1_COL20_ROW39_S20         3367     OK             927   1352     0     0
EXP1_COL20_ROW40_S20          422     OK             294     75     0     0
[800 rows x 6 columns]

>>> exp.meta_genes
                      expressed  expressed_perc status  mitochondrial   ERCC   rRNA
ENSMUSG00000102693.1          0         0.00000     OK          False  False  False
ENSMUSG00000064842.1          0         0.00000     OK          False  False  False
ENSMUSG00000051951.5          0         0.00000     OK          False  False  False
ENSMUSG00000102851.1          0         0.00000     OK          False  False  False
ENSMUSG00000103377.1          1         0.00125     OK          False  False  False
...                         ...             ...    ...            ...    ...    ...
ERCC-00164                  145         0.18125     OK          False   True  False
ERCC-00165                   25         0.03125     OK          False   True  False
ERCC-00168                  123         0.15375     OK          False   True  False
ERCC-00170                   91         0.11375     OK          False   True  False
ERCC-00171                   32         0.04000     OK          False   True  False
[45884 rows x 6 columns]

Adding meta data
^^^^^^^^^^^^^^^^
Meta data such as experimental categories (e.g. tissue, time points, batches, etc) can easily be added to your adobo object by calling :py:func:`adobo.data.dataset.add_meta_data`, which takes four parameters:

1. ``axis`` can be either 'cells' or 'genes' depending on whether your added data represent data for cells or genes.
2. the ``key`` is used as variable name, choose something that makes sense, such as "tissue" for different tissues.
3. ``data`` should be a ``list``, a numpy array or a Pandas Series, containing your data with the same length as your ``axis`` (although if ``data`` is of type `pandas.Series <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html>`_ the length does not need to match as long as ``index`` is set in the Series).
4. ``type_`` (note, this one has a trailing underscore) indicates if the data are categorical or continuous (defaults to categorical).

Getting detailed help
^^^^^^^^^^^^^^^^^^^^^
All functions in adobo have full documentation, which is accessible as `docstrings <https://www.python.org/dev/peps/pep-0257/>`_ on the Python interactive console as well as online:

.. code-block:: python3

   help(ad)
   help(ad.IO.load_from_file)

Data examination
^^^^^^^^^^^^^^^^
After loading the data a first step is to examine number of reads per cell in a bar plot. It helps to identify extreme outliers that may represent artifacts (unusually low number of reads per cell or unusually high number of reads per cell):

.. code-block:: python3

   ad.plotting.reads_per_cell(exp)

Which will generate the plot:

.. image:: 2019-08-30-131424_587x441_scrot.png

It is also informative to examine number of expressed genes per cell:

.. code-block:: python3

   ad.plotting.genes_per_cell(exp)

.. image:: 2019-08-30-131930_594x451_scrot.png

Detecting ERCC spikes
^^^^^^^^^^^^^^^^^^^^^
ERCC are known amounts of synthetic constructs added to RNA-seq libraries for quality control and normalization purposes :cite:`Jiang2011`. Not all experiments use ERCC spikes, but many do. The ERCC "genes" are usually prefixed with `ERCC-` in the gene expression matrix. This function is used to annotate them so that they are not included in downstream analyses.

The :py:func:`adobo.preproc.find_ercc` is used to flag the ERCC spikes (stored in the ``ERCC`` column of :py:attr:`adobo.data.dataset.meta_genes`):

.. code-block:: python3

   ad.preproc.find_ercc(exp, ercc_pattern='^ERCC[_-]\\S+$')

Detecting mitochondrial genes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Mitochondrial gene expression signals can serve to indirectly tell us how healthy the captured cells are. Dying and low quality cells tend to exhibit unusually high signal from these genes. One convenient function identifies mitochondrial genes in your data and adds the percent of mitochondrial gene expression to the cellular meta data. Often mitochondrial genes in the human and mouse genomes have gene symbols starting with the prefix ``mt-``, but this might vary from species to species.

.. code-block:: python3

   ad.preproc.find_mitochondrial_genes(exp, mito_pattern='^mt-')

Sometimes a regular expression is not possible and we can instead supply a list of gene IDs or symbols representing mitochondrial genes:

.. code-block:: python3

   ad.preproc.find_mitochondrial_genes(exp, genes=['geneA','geneB','geneC'])

Applying simple filters
^^^^^^^^^^^^^^^^^^^^^^^
Simple filters refers to applying a strict minimum cutoff on the number of expressed genes per cell and the total read depth per cell. Simple filters are usually effective in removing low quality cells and uninformative genes. If your data come from Drop-seq, 10X, etc, requiring at least 1000 uniquely mapped reads per cell is often sufficient:

.. code-block:: python3

   ad.preproc.simple_filter(exp, minreads=1000, minexpgenes=0.001)

.. important::

   If your protocol is applying full-length mRNA sequencing, e.g. SMART-seq2, then your ``minreads`` threshold should be higher, for example 50000.

.. note::

   :py:func:`adobo.preproc.simple_filter` also has a `maxreads` parameter, which can be used to remove cells with an upper read count limit (perhaps useful for limiting doublets). However, this parameter is not set by default.

It is also desirable to remove genes with an expression signal in very few cells; such genes may contribute more noise than information. The ``minexpgenes`` parameter can be used to control how genes are filtered out. If you wish to not remove any genes at all, simply set it to zero:

.. code-block:: python3

   ad.preproc.simple_filter(exp, minreads=1000, minexpgenes=0)

Setting ``minexpgenes`` to a fraction indicates that at least that fraction of cells must express any gene. If ``minexpgenes`` is an integer it refers to the absolute number of cells that at minimum must express the gene for the gene not to be filtered out.

To reset all simple filters to original:

.. code-block:: python3

   exp.reset_filters()

Automatic detection of low quality cells
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A more sophisticated approach to detection of low quality cells is to use the function :py:func:`adobo.preproc.find_low_quality_cells`, which uses `Mahalanobis distance`_ to identify bad cells from five quality metrics.

.. important::

   ``find_low_quality_cells`` requires that there are ERCC spikes in your data.

The parameter ``rRNA_genes`` should either be a string containing the full path to a file on disk contaiing genes that are rRNA genes (the file should have one gene per line). ``rRNA_genes`` can also be a :py:class:`pandas.Series` object with gene symbols.

.. code-block:: python3

   ad.preproc.find_low_quality_cells(exp, rRNA_genes=rRNA)

Like all adobo functions, ``find_low_quality_cells`` modifies the passed object. However, ``find_low_quality_cells`` also returns a list of cells that are classified as low quality; to prevent such behavior simply assign the return to a variable:

.. code-block:: python3

   low_q_cells = ad.preproc.find_low_quality_cells(exp, rRNA_genes=rRNA)

Normalization
=============
Normalization removes technical and sometimes experimental biases and is always necessary prior to analysis. Because a universal normalization scheme for scRNA-seq data is not available nor recommended, adobo supports several different procedures. The function :py:func:`adobo.normalize.norm` can be used to perform the following normalization methods:

**standard**
   Performs a standard normalization by scaling with the total read depth per cell and then multiplying with a scaling factor.

**rpkm**
   Normalizes read counts as Reads per kilo base per million mapped reads (RPKM) :cite:`Conesa2016`. This method should be used if you need to adjust for gene length, such as in a SMART-Seq2 protocol. To use this procedure you must first prepare a file containing combined exon lengths for genes; the file should contain two columns, **without a header**, and columns separated by one space. The following columns must be present: (1) gene symbols and (2) the sum of exon lengths. The filename is set with the ``gene_lengths`` parameter, which can also take a vector.

**fqn**
   Performs full quantile normalization :cite:`Bolstad2003`. FQN was a popular normalization scheme for microarray data. It is not very common in single cell analysis despite having been shown to perform well :cite:`Cole2018`. The present implementation does not handle ties well.

**clr**
   Centered log ratio normalization. This normalization scheme was introduced in Seurat version 3.0 :cite:`Stuart2018`. It is a simple normalization scheme and is an alternative to ``standard``.

**vsn**
   Variance stabilizing normaliztion based on a negative binomial regression model with regularized parameters. Introduced by :cite:`Hafemeister2019` and represents a more sophisticated normalization approach. Appears to marginally improve resolution. Can be used if you have UMI counts.

All normalization schemes can be followed by log2-transformation by setting ``log2=True``, which is the default.

To perform a ``standard`` normalization followed by ``log``-transformation, run:

.. code-block:: python3

   ad.normalize.norm(exp, method='standard')
   ad.normalize.norm(exp, method='clr')

The normalized data are stored in the attribute :py:attr:`adobo.data.dataset.norm_data`, which is a dictionary of dictionaries. If we run multiple normalizations they are all stored in the ``norm_data`` and we can use the name ``name`` parameter in :py:func:`adobo.normalize.norm` to give it a name (default name is the method). We can always call ``is_normalized()`` to determine if a dataset has been normalized:

>>> exp.is_normalized()
True

.. note::

   If you have previously executed :py:func:`adobo.preproc.find_ercc`, ERCC spikes will be normalized too, and these can be found in :py:attr:`adobo.data.dataset.norm_ercc`.

Examining analysis history
==========================
Downstream analyses are performed on the data object. At any time it's possible to examine what functions have been applied on data object by calling :py:func:`adobo.data.dataset.assays`:

>>> exp.assays()
Number of mitochondrial genes found: 0
Number of ERCC spikes found: 92 
Normalization method: <not performed yet> 
Has HVG discovery been performed? No

Detection of highly variable genes
==================================
Many algorithms used in scRNA-seq analysis perform better when used on a subset of measured genes :cite:`Yip2018`; the goal of the feature selection step is usually to extract a set highly variable genes (HVG). adobo currently implements the following strategies for HVG discovery:

**seurat** 
    The function bins the genes according to average expression, then calculates dispersion for each bin as variance to mean ratio. Within each bin, Z-scores are calculated and returned. Z-scores are ranked and the top 1000 are selected. Input data should be normalized first. This strategy was introduced in Seruat :cite:`Stuart2018`, it is simple yet highly effective in identifying HVG.

**brennecke**
    Implements the method described in :cite:`Brennecke2013`. ``brennecke`` estimates and fits technical noise using ERCC spikes (technical genes) by fitting a generalized linear model with a gamma function and identity link and the parameterization w=a_1+u+a0. It then uses the chi2 distribution to test the null hypothesis that the squared coefficient of variation does not exceed a certain minimum. False discovery rate (FDR)<0.10 is considered significant.

**scran**
    scran fits a polynomial regression model to technical noise by modeling the variance versus mean gene expression relationship of ERCC spikes (the original method used local regression) :cite:`Lun2016`. It then decomposes the variance of the biological gene by subtracting the technical variance component and returning the biological variance component.

**chen2016**
    This method uses linear regression, subsampling, polynomial fitting and gaussian maximum likelihood estimates to derive a set of HVG :cite:`Chen2016`.

**mm**
    Selection of HVG by modeling dropout rates using modified Michaelis-Menten kinetics :cite:`Andrews2018`. This method calculates dropout rates and mean expression for every gene, then models these with the Michaelis-Menten equation (parameters are estimated with maximum likelihood optimization). The basis for using MM is because most dropouts are caused by failure of the enzyme reverse transcriptase, thus the dropout rate can be modelled with theory developed for enzyme reactions. This implementation works best for libraries sequenced to saturation (i.e. not Drop-seq).

Example:

.. code-block:: python3

   ad.hvg.find_hvg(exp, method='seurat', ngenes=1000)

The results are stored in :py:attr:`adobo.data.dataset.hvg`.

Dimensional reduction
=====================
These are techniques to reduce the number of dimensions under consideration. After running these functions, results are stored in the ``dict`` :py:attr:`adobo.data.dataset.dr`.

Principal Component analysis (PCA)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`PCA <https://en.wikipedia.org/wiki/Principal_component_analysis>`_ decomposition :cite:`Abdi2010` of single cell data is for the most part necessary prior to clustering. The reason for this is because the graph construction benefits from a strong signal from each feature. PCA computation in adobo is performed by invoking :py:func:`adobo.dr.pca()`. Scaling of the data should always be performed before PCA, and this is done by default (although it can be turned off by setting ``scale=False``). Two approaches are available for PCA decomposition, and it should not matter much which one is used:

**irlb**
    Computed via truncated singular value decomposition by implicitly restarted Lanczos bidiagonalization :cite:`Baglama2005`. `irlb` may be better at handling very large single cell datasets and it is the default.

**svd**
    The standard approach to PCA. Computed via singular value decomposition (svd). (More likely to raise ``MemoryError``.)

Examples:

.. code-block:: python3

   # 75 components are returned by default, may need to be adjusted depending on your dataset
   ad.dr.pca(exp, method='irlb', ncomp=75)

   ad.dr.pca(exp, method='svd', ncomp=75)

.. note::

   PCA components are stored in the dictionary :py:attr:`adobo.data.dataset.dr` and variable contributions are stored in the dictionary :py:attr:`adobo.data.dataset.dr_gene_contr`.

We can now examine the top contributing genes to each PCA component by producing a plot with :py:func:`adobo.plotting.pca_contributors`.

To plot the top 10 contributing genes to the first five components:

.. code-block:: python3

   ad.plotting.pca_contributors(exp, dim=[0,1,2,3,4], top=10)

.. image:: pca_contributors.png

We can also write the output to a file instead of showing it on the screen:

.. code-block:: python3

   ad.plotting.pca_contributors(exp, dim=[0,1,2,3,4], top=10, filename='top_pca_genes.pdf')

t-Distributed Stochastic Neighbor Embedding (t-SNE)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
t-SNE :cite:`vanDerMaaten2008` is a non-linear dimensional reduction technique that optimizes for local distance. It is the *de facto* dimensional reduction technique used to visualize scRNA-seq data :cite:`Kobak2019`. adobo uses the scikit-learn implementation :cite:`Pedregosa2011`. The most important parameter is ``perplexity`` (related to number of nearest neighbors) and it can greatly influence how your plot looks like. Suggested values for ``perplexity`` lies between 5 and 50, and it is recommened to try higher values for datasets with more cells. Additional parameters (such as early_exaggeration, learning_rate, n_iter, and n_iter_without_progress) do not usually need to be specified but will be passed into :py:class:`sklearn.manifold.TSNE`. By default adobo runs t-SNE on the PCA decomposition:

.. code-block:: python3

   ad.dr.tsne(exp, perplexity=30)

The recommended approach is to run t-SNE on PCA components, but it can sometimes be informative to run it on your entire normalized expression matrix (this will take significantly longer time):

.. code-block:: python3

   ad.dr.tsne(exp, target='norm', verbose=True)

.. note::

   t-SNE is non-deterministic. Different runs can give different results. To get a more reproducible t-SNE plot consider setting the ``seed`` parameter to any random integer, which will generate reproducible random numbers.

Uniform Manifold Approximation and Projection (UMAP)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
UMAP :cite:`McInnes2018` is also used frequently to visualize scRNA-seq data, and it may be better at preserving the global structure of the data:

.. code-block:: python3

   ad.dr.umap(exp)

.. toctree::
   :maxdepth: 2
   :caption: Contents:

Clustering
==========
A crucial step in scRNA-seq analysis is to group cells into clusters. Complex datasets consisting of thousands of cells can be reduced to a small number of clusters, which tend to be easier to analyze and interpret.

.. important::

   Clustering is performed in PCA space, therefore PCA components must have been calculated first using :py:func:`adobo.dr.pca`.

In adobo, clustering can be performed with a single line of code:

.. code-block:: python3

   # to run leiden with the resolution set to 0.8 (only applicable for leiden)
   ad.clustering.generate(exp, distance='euclidean', res=0.8, clust_alg='leiden')
   
   # to run walktrap
   ad.clustering.generate(exp, distance='euclidean', clust_alg='walktrap')

The above command will run the necessary steps to cluster your single cell dataset; the cluster membership vector is stored in :py:attr:`adobo.data.dataset.clusters`, i.e. represented by an array with the same length as the number of cells after pre-processing. adobo's default clustering algorithm first builds a Shared Nearest Neighbor graph :cite:`Ertoz2003` and then finds communities in this graph using the Leiden algorithm :cite:`Traag2019` (default). It may become necessary to change value of the ``res`` (resolution) parameter to find the optimal clustering outcome.

By default :py:func:`adobo.clustering.generate` will return a ``dict`` containing cluster sizes (number of cells), use ``retx=False`` to disable this behavior.

Other community detection algorithms are also supported via the `igraph <https://igraph.org/redirect.html>`_ package:

* ``walktrap`` :cite:`Pons2006`
* ``spinglass`` :cite:`Reichardt2006`
* ``multilevel`` :cite:`Blondel2008`
* ``infomap`` :cite:`Rosvall2008`
* ``label_prop`` (label propagation) :cite:`Raghavan2007`
* ``leading_eigenvector`` (Newman's leading eigenvector method) :cite:`Newman2006`

Various parameters of the these algorithms can be changed in :py:func:`adobo.clustering.generate`.

.. note::

   ``spinglass`` does not scale well on large datasets :cite:`Yang2016`.

Clustering visualization
========================
Visualization of cells in 2d space is performed with the function :py:func:`adobo.plotting.cell_viz`. Before running ``cell_viz``, the appropriate reduction functions must have been invoked (t-SNE or UMAP; see above). ``cell_viz`` can plot custom meta data, gene expression, and clustering outcomes. Three parameters specified as tuples control what to plot:

``clustering``
    Default is 'leiden'.
``metadata``
    Specify variable(s) listed as meta data in :py:attr:`adobo.data.dataset.meta_cells` (added via :py:func:`adobo.data.dataset.add_meta_data`).
``genes``
    Specify any gene symbol(s).

The above parameters can be mixed and will in such cases generate one subplot for every specified variable. The ``ncols`` parameter can be used to set the number of columns in the plot (default is 2).

Examples:

.. code-block:: python3

   # tsne
   ad.plotting.cell_viz(exp, reduction='tsne', clustering='leiden', metadata='detected_genes')
   
   # plots 'leiden' by default
   ad.plotting.cell_viz(exp, reduction='umap')

Plotting mitochondrial gene expression:

.. code-block:: python3

   ad.plotting.cell_viz(exp, reduction='tsne', meta_data='mito_perc', clustering=(), genes=())

.. image:: mito_perc_tsne.png
   :align: center
   
Cell cycle prediction
=====================
An extreme simplification of the cell cycle is shown below (figure from Wikipedia). It is often useful to get an understanding of cell cycle states in a new data set, and it boils down to predicting one of three cell cycle states for every cell: G1, S and G2M.

.. image:: cell_cycle_wikipedia.png
   :align: center
   :alt: Source: Wikipedia

adobo contains a machine learning classifier based on the sklearn implementation of `Stochastic Gradient Descent <https://en.wikipedia.org/wiki/Stochastic_gradient_descent>`_. The classifier is trained on mouse embryonic stem cells (n=288 cells) :cite:`Buettner2015`. The original data can be retrieved from `here <https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2805/>`_. Cell cycle classification is performed by calling two functions:

.. code-block:: python3

   # trains the classifier
   clf, tr_features = ad.bio.cell_cycle_train()
   
   # performs the actual classification of cells in your data
   ad.bio.cell_cycle_predict(obj, clf, tr_features)

Classification is stored in the attribute :py:attr:`adobo.data.dataset.meta_cells` in a column `cell_cycle`. The current design does not support prediction scores, although this can easily be changed by changing the `loss parameter <https://scikit-learn.org/stable/modules/sgd.html>`_.

We can visualize the results:

.. code-block:: python3

   ad.plotting.cell_viz(obj, metadata='cell_cycle', clustering=(), genes=())

.. important::

   Prediction is only valid on mouse data since the classifier is trained on mouse data. Make sure your gene expression contains Ensembl gene identifiers in one of the following two formats: ENSEMBL; GENESYMBOL_ENSEMBL.

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`

.. _scRNA-seq: https://en.wikipedia.org/wiki/Single_cell_sequencing
.. _Mahalanobis distance: https://en.wikipedia.org/wiki/Mahalanobis_distance

References
==========
.. bibliography:: references.bib
   :style: unsrt
