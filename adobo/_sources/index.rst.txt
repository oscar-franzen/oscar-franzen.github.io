Welcome to adobo's documentation!
#################################

What adobo is
*************
adobo is an analysis framework consisting of a set of Python modules to enable exploratory analysis of single cell RNA-seq data (`scRNA-seq`_). adobo can be used to compose scripts, used in interactive workflows and much more. adobo is developed by Oscar FranzÃ©n (limited support is available over e-mail: p.oscar.franzen@gmail.com).

.. note::

   adobo is developed and tested on Python version 3.5.3 - older versions may work but are untested.

Author contact or Support
=========================

Installation
============
The easiest way to install adobo is to clone the GitHub repository:

.. code-block:: bash

   $ git clone https://github.com/oscar-franzen/adobo.git

Support for ``pip3`` installation is on the TODO list.

Getting started
===============
Loading the package
^^^^^^^^^^^^^^^^^^^
The first step is to load the adobo package by importing it:

.. code-block:: python3

   import adobo as ad

Loading your data from a text file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First we need to create a new adobo object, which is an instance of the class :class:`adobo.data.dataset`. This will be a new object containing your single cell data. The input file should be a gene expression matrix (rows as genes and cells as columns). Fields can be separated by any character (default is tab) and it can be changed with the `sep` argument. The data matrix file can have a header or not (``header=0`` indicates a header is present, otherwise use ``header=None``). If the header of your gene expression matrix contains a label for gene symbols, set ``column_id=True``. The function :py:func:`adobo.IO.load_from_file` is used to load data from a raw read count matrix:

.. code-block:: python3

   data = ad.IO.load_from_file('GSE95315.tab', column_id=True)

.. important::

   The loaded data must not be normalized, i.e. it should be raw read counts.

.. note::

   All downstream operations and analyses are performed and stored in an adobo object, i.e. functions are applied on this object.

.. note::

   Most adobo functions also have a ``verbose`` argument, which when ``True`` makes the function more noisy.

Getting detailed help
^^^^^^^^^^^^^^^^^^^^^
All functions in adobo have extensive documentation, which are accessible as docstrings on the Python interactive console as well as online:

.. code-block:: python3

   help(ad)
   help(ad.IO.load_from_file)


Loading compressed data
^^^^^^^^^^^^^^^^^^^^^^^
scRNA-seq is zero inflated, and therefore compress strongly. We can load the compressed data directly without having to uncompress it first; the compression format is detected automatically (gzip, bz2, zip and xz are supported). For example:

.. code-block:: python3

   data = ad.IO.load_from_file('GSE95315.tab.gz', column_id=True)

Your gene expression data is stored in the attribute ``data.exp_mat``, and after loading it is good to examine that the data were loaded properly:

>>> data
53,889 genes and 384 cells were loaded

Data examination
^^^^^^^^^^^^^^^^
It's can be useful to examine number of reads per cell in a barplot format:

.. code-block:: python3

   ad.plotting.barplot_reads_per_cell(data)

Which will generate the plot:

.. image:: 2019-08-30-131424_587x441_scrot.png

It is also a good idea to examine number of expressed genes per cell:

.. code-block:: python3

   ad.plotting.barplot_genes_per_cell(data)

.. image:: 2019-08-30-131930_594x451_scrot.png

Cleaning your data
^^^^^^^^^^^^^^^^^^
Before we proceed to normalization we should start with some data cleaning. A good first step is to look for empty cells and genes. Empty genes/cells do obviously not carry any information and can be removed:

.. code-block:: python3

   ad.preproc.remove_empty(data)

Detecting ERCC spikes
^^^^^^^^^^^^^^^^^^^^^
ERCC are known amounts of synthetic constructs added to RNA-seq libraries for quality control and normalization purposes :cite:`Jiang2011`. Not all experiments use ERCC spikes, but many do. The ERCC "genes" are usually prefixed with `ERCC-` in the gene expression matrix. This function is used to put them aside so that they are not included in downstream analyses.

.. note::

   The ``ERCC_pattern`` argument can be used to set a regular expression for detecting these "genes".

The :py:func:`adobo.preproc.detect_ERCC_spikes` is used to filter out the ERCC (stored in :py:attr:`adobo.data.dataset._exp_ERCC`):

.. code-block:: python3

   ad.preproc.detect_ERCC_spikes(data)

Detecting mitochondrial genes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
It's often a good idea not to include the mitochondrial genes in the analysis and some downstream analyses require that adobo knows which genes are mitochondrial. Usually the mitochondrial genes in human and mouse genomes have gene symbols starting with the prefix ``mt-``, but this might vary from species to species.

.. code-block:: python3

   ad.preproc.detect_mito(data)

Or specify a custom regular expression to identify them:

.. code-block:: python3

   ad.preproc.detect_mito(data, mito_pattern='^mito-')

Applying simple filters
^^^^^^^^^^^^^^^^^^^^^^^
Simple filters refers to applying a strict minimum cutoff on the number of expressed genes per cell and the total read depth per cell. Simple filters are usually effective in removing low quality cells and uninformative genes. If your data come from Drop-seq, 10X, etc, requiring at least 1000 uniquely mapped reads per cell is often sufficient:

.. code-block:: python3

   ad.preproc.simple_filter(data, minreads=1000, minexpgenes=0.001)

.. important::

   If your protocol is applying full-length mRNA sequencing, e.g. SMART-seq2, then your ``minreads`` threshold should be higher, for example 10000.

It is also desirable to remove genes with an expression signal in very few cells; such genes may contribute more noise than information. The ``minexpgenes`` argument can be used to control how genes are filtered out. If you wish to not remove any genes at all, simply set it to zero:

.. code-block:: python3

   ad.preproc.simple_filter(data, minreads=1000, minexpgenes=0)

Setting ``minexpgenes`` to a fraction indicates that at least that fraction of cells must express any gene. If ``minexpgenes`` is an integer it refers to the absolute number of cells that at minimum must express the gene for the gene not to be filtered out.

Automatic detection of low quality cells
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A more sophisticated approach to detection of low quality cells is to use the function :py:func:`adobo.preproc.find_low_quality_cells`, which uses `Mahalanobis distance`_ to identify bad cells from five quality metrics.

.. important::

   ``find_low_quality_cells`` requires that there are ERCC spikes in your data.

The argument ``rRNA_genes`` should either be a string containing the full path to a file on disk contaiing genes that are rRNA genes (the file should have one gene per line). ``rRNA_genes`` can also be a :py:class:`pandas.Series` object with gene symbols.

.. code-block:: python3

   ad.preproc.find_low_quality_cells(data, rRNA_genes=rRNA)

Normalization
=============
Normalization removes technical and sometimes experimental biases and is always necessary prior to analysis. Because a single normalization scheme for scRNA-seq data is not available, adobo supports several different procedures:

**standard**
   Performs a standard normalization by scaling with the total read depth per cell and then multiplying with a scaling factor.

**rpkm**
   Normalize expression values as Reads per kilo base per million mapped reads (RPKM) :cite:`Conesa2016`. This method should be used if you need to adjust for gene length, such as in a SMART-Seq2 protocol. To use this procedure you must first prepare a file containing combined exon lengths for genes; the file should contain two columns, without a header, and columns separated by one space. The following columns must be present: (1) gene symbols and (2) the sum of exon lengths.

**fqn**
   Performs full quantile normalization :cite:`Bolstad2003`. FQN was a popular normalization scheme for microarray data. It is not very common in single cell analysis despite having been shown to perform well :cite:`Cole2018`. The present implementation does not handle ties well.

**clr**
   Centered log ratio normalization. This normalization scheme was introduced in Seurat version 3.0 :cite:`Stuart2018`. A simple normalization scheme and might be an alternative to ``standard``.

**vsn**
   Variance stabilizing normaliztion based on a negative binomial regression model with regularized parameters. Introduced by :cite:`Hafemeister2019` and represents the most complex scheme of the above; appears to improve resolution somewhat.

All normalization schemes, except ``vsn``, can be followed by ``log2`` transformation.

To perform a ``standard`` normalization run:

.. code-block:: python3

   ad.normalize.norm(data, method='standard')

.. toctree::
   :maxdepth: 2
   :caption: Contents:

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`

.. _scRNA-seq: https://en.wikipedia.org/wiki/Single_cell_sequencing
.. _Mahalanobis distance: https://en.wikipedia.org/wiki/Mahalanobis_distance

References
==========
.. bibliography:: references.bib
   :style: unsrt
