
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Welcome to adobo’s documentation! &#8212; adobo  documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">adobo  documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to adobo’s documentation!</a><ul>
<li><a class="reference internal" href="#what-adobo-is">What adobo is</a></li>
<li><a class="reference internal" href="#contact-developer-and-maintainer">Contact developer and maintainer</a><ul>
<li><a class="reference internal" href="#notes-on-this-document">Notes on this document</a></li>
<li><a class="reference internal" href="#finding-tutorials">Finding tutorials</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#package-organization">Package organization</a><ul>
<li><a class="reference internal" href="#internal-modules">Internal modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getting-started-and-pre-processing-your-data">Getting started and pre-processing your data</a><ul>
<li><a class="reference internal" href="#loading-the-package">Loading the package</a></li>
<li><a class="reference internal" href="#loading-your-data-from-a-text-file">Loading your data from a text file</a></li>
<li><a class="reference internal" href="#creating-the-data-class-object-directly-from-a-pandas-data-frame">Creating the data class object directly from a pandas data frame</a></li>
<li><a class="reference internal" href="#saving-object">Saving object</a></li>
<li><a class="reference internal" href="#accessing-meta-data-for-cells-and-genes">Accessing meta data for cells and genes</a></li>
<li><a class="reference internal" href="#adding-meta-data">Adding meta data</a></li>
<li><a class="reference internal" href="#getting-detailed-help">Getting detailed help</a></li>
<li><a class="reference internal" href="#data-examination">Data examination</a></li>
<li><a class="reference internal" href="#detecting-ercc-spikes">Detecting ERCC spikes</a></li>
<li><a class="reference internal" href="#detecting-mitochondrial-genes">Detecting mitochondrial genes</a></li>
<li><a class="reference internal" href="#applying-simple-filters">Applying simple filters</a></li>
<li><a class="reference internal" href="#dynamic-detection-of-low-quality-cells">Dynamic detection of low quality cells</a></li>
<li><a class="reference internal" href="#imputation-of-dropouts">Imputation of dropouts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#normalization">Normalization</a></li>
<li><a class="reference internal" href="#examining-analysis-history">Examining analysis history</a></li>
<li><a class="reference internal" href="#detection-of-highly-variable-genes">Detection of highly variable genes</a></li>
<li><a class="reference internal" href="#dimensional-reduction">Dimensional reduction</a><ul>
<li><a class="reference internal" href="#principal-component-analysis-pca">Principal Component analysis (PCA)</a></li>
<li><a class="reference internal" href="#t-distributed-stochastic-neighbor-embedding-t-sne">t-Distributed Stochastic Neighbor Embedding (t-SNE)</a></li>
<li><a class="reference internal" href="#uniform-manifold-approximation-and-projection-umap">Uniform Manifold Approximation and Projection (UMAP)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#clustering">Clustering</a></li>
<li><a class="reference internal" href="#clustering-visualization">Clustering visualization</a></li>
<li><a class="reference internal" href="#cell-cycle-prediction">Cell cycle prediction</a></li>
<li><a class="reference internal" href="#cell-type-prediction">Cell type prediction</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-adobo-s-documentation">
<h1>Welcome to adobo’s documentation!<a class="headerlink" href="#welcome-to-adobo-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-adobo-is">
<h2>What adobo is<a class="headerlink" href="#what-adobo-is" title="Permalink to this headline">¶</a></h2>
<p>adobo is an analysis framework for single cell RNA sequencing data (scRNA-seq) and enables exploratory analysis through a set of Python modules. adobo can be used to compose scripts, used in interactive workflows and much more. The goal of adobo is to consolidate single cell computational analysis methods in the Python 3.x programming language. adobo can be used to construct new pipelines and workflows in order to facilitate biological interpretation of scRNA-seq data.</p>
</div>
<div class="section" id="contact-developer-and-maintainer">
<h2>Contact developer and maintainer<a class="headerlink" href="#contact-developer-and-maintainer" title="Permalink to this headline">¶</a></h2>
<p>adobo is developed by Oscar Franzén at Karolinska Institutet. Limited support is available over e-mail: <a class="reference external" href="mailto:p&#46;oscar&#46;franzen&#37;&#52;&#48;gmail&#46;com">p<span>&#46;</span>oscar<span>&#46;</span>franzen<span>&#64;</span>gmail<span>&#46;</span>com</a> or <a class="reference external" href="mailto:oscar&#46;franzen&#37;&#52;&#48;ki&#46;se">oscar<span>&#46;</span>franzen<span>&#64;</span>ki<span>&#46;</span>se</a></p>
<div class="section" id="notes-on-this-document">
<h3>Notes on this document<a class="headerlink" href="#notes-on-this-document" title="Permalink to this headline">¶</a></h3>
<p>Some basic knowledge of Python, <a class="reference external" href="https://en.wikipedia.org/wiki/NumPy">NumPy</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Pandas_(software)">pandas</a> and their commonly used data structures is helpful but not necessary. Many of adobo’s functions have parameters with sensible defaults so that all parameters don’t need to be specified upon calling a specific function. For clarity, the most important parameters are shown in the examples below.</p>
<p>We refer to the adobo package as ‘ad’.</p>
</div>
<div class="section" id="finding-tutorials">
<h3>Finding tutorials<a class="headerlink" href="#finding-tutorials" title="Permalink to this headline">¶</a></h3>
<p>Jupyter notebooks can be found <a class="reference external" href="https://github.com/oscar-franzen/adobo/tree/master/notebooks">here</a>.</p>
</div>
<div class="section" id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h3>
<p>First step is to install adobo. The recommended way to install adobo is to first clone the GitHub repository and then use <code class="docutils literal notranslate"><span class="pre">pip3</span></code> from your terminal, which will also install necessary dependencies (instead of using git one can also navigate to the <a class="reference external" href="https://github.com/oscar-franzen/adobo/">repository</a> and press the download button):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/oscar-franzen/adobo.git

$ <span class="nb">cd</span> adobo

<span class="c1"># local installation</span>
$ pip3 install --user .

<span class="c1"># below installs adobo without package dependencies (not recommended)</span>
$ pip3 install --user --no-deps .
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Support for <code class="docutils literal notranslate"><span class="pre">PyPI</span></code> is on the TODO list.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>adobo is developed and tested on Python version 3.6.x; older versions may work but are untested.</p>
</div>
<p>After installing it, you can now delete the cloned repository and test that everything works by firing up your Python 3 interpreter (the  <code class="docutils literal notranslate"><span class="pre">OPENBLAS_NUM_THREADS</span></code> environmental variable prevents unexpected low-level multithreading):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">export</span> <span class="nv">OPENBLAS_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>

$ python3
</pre></div>
</div>
<p>Try importing the library and it should greet you with the current version and the URL to the documentation (this page):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">adobo</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="go">adobo version 0.1. Documentation: https://oscar-franzen.github.io/adobo/</span>
</pre></div>
</div>
</div>
<div class="section" id="package-organization">
<h3>Package organization<a class="headerlink" href="#package-organization" title="Permalink to this headline">¶</a></h3>
<p>adobo is organized into several modules containing related functions. All module and function names are lowercase to make them easier to remember.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module name</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">preproc</span></code></p></td>
<td><p>data preprocessing</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">data</span></code></p></td>
<td><p>the dataset container class</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dr</span></code></p></td>
<td><p>dimensional reduction techniques</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hvg</span></code></p></td>
<td><p>highly variable gene discovery</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">normalize</span></code></p></td>
<td><p>normalization of raw read counts</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">IO</span></code></p></td>
<td><p>reading and writing data (input/output)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">clustering</span></code></p></td>
<td><p>functions related to data clustering operations</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">de</span></code></p></td>
<td><p>differential expression between cell clusters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">plotting</span></code></p></td>
<td><p>data visualization</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bio</span></code></p></td>
<td><p>functions related to biology, for example cell cycle and cell type prediction</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stats</span></code></p></td>
<td><p>miscellaneous or general statistical functions that don’t fit anywhere else</p></td>
</tr>
</tbody>
</table>
<div class="section" id="internal-modules">
<h4>Internal modules<a class="headerlink" href="#internal-modules" title="Permalink to this headline">¶</a></h4>
<p>These do not need to be accessed but are listed here for documentation purposes.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module name</p></th>
<th class="head"><p>Function content</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">_colors</span></code></p></td>
<td><p>related to color generation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">_log</span></code></p></td>
<td><p>internal utilities</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">_constants</span></code></p></td>
<td><p>internal constants</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="getting-started-and-pre-processing-your-data">
<h3>Getting started and pre-processing your data<a class="headerlink" href="#getting-started-and-pre-processing-your-data" title="Permalink to this headline">¶</a></h3>
<div class="section" id="loading-the-package">
<h4>Loading the package<a class="headerlink" href="#loading-the-package" title="Permalink to this headline">¶</a></h4>
<p>The first step is to load the adobo package by importing it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">adobo</span> <span class="k">as</span> <span class="nn">ad</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Debug information in the form of traceback output is suppressed by default. However, this information is often useful when trying to solve program bugs. To enable full traceback set:</p>
<p><code class="docutils literal notranslate"><span class="pre">ad.debug=1</span></code></p>
</div>
</div>
<div class="section" id="loading-your-data-from-a-text-file">
<h4>Loading your data from a text file<a class="headerlink" href="#loading-your-data-from-a-text-file" title="Permalink to this headline">¶</a></h4>
<p>First we need to create a new adobo object, which is an instance of the class <a class="reference internal" href="adobo.html#adobo.data.dataset" title="adobo.data.dataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">adobo.data.dataset</span></code></a>. This will be a new object containing the single cell data, meta data and analysis results. The input file should be a gene expression matrix (rows as genes and cells as columns) in plain text format. Fields can be separated by any character and it can be changed with the <code class="docutils literal notranslate"><span class="pre">sep</span></code> parameter. <code class="docutils literal notranslate"><span class="pre">sep</span></code> can be a single character or a regular expression (default is the regular expression <code class="docutils literal notranslate"><span class="pre">\s</span></code>). The data matrix file can have a header or not (<code class="docutils literal notranslate"><span class="pre">header=True</span></code> indicates a header is present, otherwise use <code class="docutils literal notranslate"><span class="pre">header=False</span></code>). <a class="reference internal" href="adobo.html#adobo.IO.load_from_file" title="adobo.IO.load_from_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.IO.load_from_file()</span></code></a> calls <a class="reference external" href="https://datatable.readthedocs.io/en/latest/">datatable.fread</a> and any additional parameters are passed on into this method. The function <a class="reference internal" href="adobo.html#adobo.IO.load_from_file" title="adobo.IO.load_from_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.IO.load_from_file()</span></code></a> is used to load data from a raw read counts matrix and the returned object is an instance of <a class="reference internal" href="adobo.html#adobo.data.dataset" title="adobo.data.dataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">adobo.data.dataset</span></code></a>.</p>
<p>We can load compressed data directly without having to uncompress it first; the compression format is detected automatically (<code class="docutils literal notranslate"><span class="pre">gzip</span></code>, <code class="docutils literal notranslate"><span class="pre">bz2</span></code>, <code class="docutils literal notranslate"><span class="pre">zip</span></code> and <code class="docutils literal notranslate"><span class="pre">xz</span></code> are supported).</p>
<p>In the below example we set <code class="docutils literal notranslate"><span class="pre">bundled=True</span></code>, which tells adobo to search its internal <code class="docutils literal notranslate"><span class="pre">data</span></code> directory for the file. For normal data, <code class="docutils literal notranslate"><span class="pre">bundled</span></code> should be <code class="docutils literal notranslate"><span class="pre">False</span></code> (default).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># example 1</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">IO</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s1">&#39;GSE95315.tab.gz&#39;</span><span class="p">,</span>
                           <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;mouse brain data&#39;</span><span class="p">,</span>
                           <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">bundled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1"># used to load &quot;internal&quot; data</span>
                           <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># example 2</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">IO</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s1">&#39;GSE95315.tab.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">desc</span></code> can be used to specify an arbitrary string describing the data, but it can also be left empty. The raw read counts matrix is stored in the attribute <code class="docutils literal notranslate"><span class="pre">count_data</span></code> inside the dataset object (<a class="reference internal" href="adobo.html#adobo.data.dataset.count_data" title="adobo.data.dataset.count_data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.count_data</span></code></a>). Here we use data from <a class="reference external" href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE95315">GEO95315</a> and it ships with adobo. By default the data are stored in a sparse data frame; sparsity can slow down the data loading step, but leaves a much smaller memory footprint. Sparsity can be turned off by setting <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> in <code class="docutils literal notranslate"><span class="pre">load_from_file</span></code>.</p>
<p>Your gene expression data is stored in the attribute <code class="docutils literal notranslate"><span class="pre">exp.count_data</span></code>, and after loading it is good practise to examine that the data were loaded properly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span>
<span class="go">53,889 genes and 384 cells were loaded</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The loaded data must <strong>not</strong> be normalized, i.e. it should be raw read counts. Non-integer values will trigger a loading error.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All downstream operations and analyses are performed and stored as attributes in the adobo object, i.e. functions are applied on this object.</p>
<p>Many adobo functions have a <code class="docutils literal notranslate"><span class="pre">verbose</span></code> parameter, which when <code class="docutils literal notranslate"><span class="pre">True</span></code> makes the function more verbose.</p>
</div>
</div>
<div class="section" id="creating-the-data-class-object-directly-from-a-pandas-data-frame">
<h4>Creating the data class object directly from a pandas data frame<a class="headerlink" href="#creating-the-data-class-object-directly-from-a-pandas-data-frame" title="Permalink to this headline">¶</a></h4>
<p>In many cases we already have our data in a data frame, in those cases we can just create the container object directly:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># where &#39;df&#39; is the data frame, columns are cells and rows are genes</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">dataset</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="saving-object">
<h4>Saving object<a class="headerlink" href="#saving-object" title="Permalink to this headline">¶</a></h4>
<p>It is convenient not having to repeat analyses once they are finished. Saving an object to disk can be done via the <code class="docutils literal notranslate"><span class="pre">joblib</span></code> package (<a class="reference external" href="https://joblib.readthedocs.io/en/latest/">complete joblib docs</a>; Python’s standard <a class="reference external" href="https://docs.python.org/3/library/pickle.html">pickle</a> is another option):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">joblib</span>

<span class="c1"># compress=0 will turn off data compression</span>
<span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="s1">&#39;test.joblib&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">exp</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;test.joblib&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Instead of writing three lines of code and always remembering the name of the output file, we can specify <code class="docutils literal notranslate"><span class="pre">output_file</span></code> in <a class="reference internal" href="adobo.html#adobo.IO.load_from_file" title="adobo.IO.load_from_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.IO.load_from_file()</span></code></a> and then calling <a class="reference internal" href="adobo.html#adobo.data.dataset.save" title="adobo.data.dataset.save"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.data.dataset.save()</span></code></a>.</p>
</div>
<div class="section" id="accessing-meta-data-for-cells-and-genes">
<h4>Accessing meta data for cells and genes<a class="headerlink" href="#accessing-meta-data-for-cells-and-genes" title="Permalink to this headline">¶</a></h4>
<p>Meta data are stored in the adobo object (an instance of <a class="reference internal" href="adobo.html#adobo.data.dataset" title="adobo.data.dataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">adobo.data.dataset</span></code></a>). Two data structures (instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) hold meta data for cells and genes, respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="o">.</span><span class="n">meta_cells</span>
<span class="go">                      total_reads status  detected_genes   mito  ERCC  rRNA</span>
<span class="go">EXP1_COL01_ROW01_S1          5935     OK             426   1455     2     0</span>
<span class="go">EXP1_COL01_ROW02_S1          3036     OK             464   1583     0     0</span>
<span class="go">EXP1_COL01_ROW03_S1         38477     OK            1961  20935     7     4</span>
<span class="go">EXP1_COL01_ROW04_S1         63962     OK            3478   4463     7     0</span>
<span class="go">EXP1_COL01_ROW05_S1          1885     OK             993    127     0     0</span>
<span class="gp">... </span>                          <span class="o">...</span>    <span class="o">...</span>             <span class="o">...</span>    <span class="o">...</span>   <span class="o">...</span>   <span class="o">...</span>
<span class="go">EXP1_COL20_ROW36_S20        43051     OK            3277   4975    29     0</span>
<span class="go">EXP1_COL20_ROW37_S20       162617     OK            4224  54144    55     0</span>
<span class="go">EXP1_COL20_ROW38_S20        56649     OK            3281   4223    31     0</span>
<span class="go">EXP1_COL20_ROW39_S20         3367     OK             927   1352     0     0</span>
<span class="go">EXP1_COL20_ROW40_S20          422     OK             294     75     0     0</span>
<span class="go">[800 rows x 6 columns]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="o">.</span><span class="n">meta_genes</span>
<span class="go">                      expressed  expressed_perc status  mitochondrial   ERCC   rRNA</span>
<span class="go">ENSMUSG00000102693.1          0         0.00000     OK          False  False  False</span>
<span class="go">ENSMUSG00000064842.1          0         0.00000     OK          False  False  False</span>
<span class="go">ENSMUSG00000051951.5          0         0.00000     OK          False  False  False</span>
<span class="go">ENSMUSG00000102851.1          0         0.00000     OK          False  False  False</span>
<span class="go">ENSMUSG00000103377.1          1         0.00125     OK          False  False  False</span>
<span class="gp">... </span>                        <span class="o">...</span>             <span class="o">...</span>    <span class="o">...</span>            <span class="o">...</span>    <span class="o">...</span>    <span class="o">...</span>
<span class="go">ERCC-00164                  145         0.18125     OK          False   True  False</span>
<span class="go">ERCC-00165                   25         0.03125     OK          False   True  False</span>
<span class="go">ERCC-00168                  123         0.15375     OK          False   True  False</span>
<span class="go">ERCC-00170                   91         0.11375     OK          False   True  False</span>
<span class="go">ERCC-00171                   32         0.04000     OK          False   True  False</span>
<span class="go">[45884 rows x 6 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="adding-meta-data">
<h4>Adding meta data<a class="headerlink" href="#adding-meta-data" title="Permalink to this headline">¶</a></h4>
<p>Meta data such as experimental categories (e.g. tissue, time points, batches, etc) can easily be added to your adobo object by calling <a class="reference internal" href="adobo.html#adobo.data.dataset.add_meta_data" title="adobo.data.dataset.add_meta_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.data.dataset.add_meta_data()</span></code></a>, which takes four parameters:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">axis</span></code> can be either ‘cells’ or ‘genes’ depending on whether your added data represent data for cells or genes.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">key</span></code> is used as variable name, choose something that makes sense, such as “tissue” for different tissues.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> should be a <code class="docutils literal notranslate"><span class="pre">list</span></code>, a numpy array or a Pandas Series, containing your data with the same length as your <code class="docutils literal notranslate"><span class="pre">axis</span></code> (although if <code class="docutils literal notranslate"><span class="pre">data</span></code> is of type <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html">pandas.Series</a> the length does not need to match as long as <code class="docutils literal notranslate"><span class="pre">index</span></code> is set in the Series).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_</span></code> (note, this one has a trailing underscore) indicates if the data are categorical or continuous (defaults to categorical).</p></li>
</ol>
</div>
<div class="section" id="getting-detailed-help">
<h4>Getting detailed help<a class="headerlink" href="#getting-detailed-help" title="Permalink to this headline">¶</a></h4>
<p>All functions in adobo have full documentation, which is accessible as <a class="reference external" href="https://www.python.org/dev/peps/pep-0257/">docstrings</a> on the Python interactive console as well as online:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>

<span class="n">help</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">IO</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="data-examination">
<h4>Data examination<a class="headerlink" href="#data-examination" title="Permalink to this headline">¶</a></h4>
<p>After loading the data a first step is to examine the number of reads per cell. Cells with an unusual high or low number of reads may be artifacts:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># These how&#39;s are supported: violin, boxplot and barplot.</span>
<span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">overall</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;reads&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;histogram&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Which will generate the plot:</p>
<img alt="_images/2019-10-24-101818_487x480_scrot.png" src="_images/2019-10-24-101818_487x480_scrot.png" />
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">overall</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;genes&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;histogram&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/2019-10-24-102111_485x485_scrot.png" src="_images/2019-10-24-102111_485x485_scrot.png" />
<p>It is also useful to relate the number of detected genes with the total read depth into a scatter plot:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">overall_scatter</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/2019-10-24-103655_496x404_scrot.png" src="_images/2019-10-24-103655_496x404_scrot.png" />
</div>
<div class="section" id="detecting-ercc-spikes">
<h4>Detecting ERCC spikes<a class="headerlink" href="#detecting-ercc-spikes" title="Permalink to this headline">¶</a></h4>
<p>ERCC are known amounts of synthetic constructs added to RNA-seq libraries for quality control and normalization purposes <a class="reference internal" href="#jiang2011" id="id1">[1]</a>. Not all experiments use ERCC spikes, but many do. The ERCC “genes” are usually prefixed with <cite>ERCC-</cite> in the gene expression matrix. This function is used to annotate them so that they are not included in downstream analyses.</p>
<p>The <a class="reference internal" href="adobo.html#adobo.preproc.find_ercc" title="adobo.preproc.find_ercc"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.preproc.find_ercc()</span></code></a> is used to flag the ERCC spikes (stored in the <code class="docutils literal notranslate"><span class="pre">ERCC</span></code> column of <a class="reference internal" href="adobo.html#adobo.data.dataset.meta_genes" title="adobo.data.dataset.meta_genes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.meta_genes</span></code></a>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">find_ercc</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">ercc_pattern</span><span class="o">=</span><span class="s1">&#39;^ERCC[_-]</span><span class="se">\\</span><span class="s1">S+$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="detecting-mitochondrial-genes">
<h4>Detecting mitochondrial genes<a class="headerlink" href="#detecting-mitochondrial-genes" title="Permalink to this headline">¶</a></h4>
<p>Mitochondrial gene expression signals can serve to indirectly tell us how healthy the captured cells are. Dying and low quality cells tend to exhibit unusually high signal from these genes. One convenient function identifies mitochondrial genes in your data and adds the percent of mitochondrial gene expression to the cellular meta data. Often mitochondrial genes in the human and mouse genomes have gene symbols starting with the prefix <code class="docutils literal notranslate"><span class="pre">mt-</span></code>, but this might vary from species to species.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">find_mitochondrial_genes</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">mito_pattern</span><span class="o">=</span><span class="s1">&#39;^mt-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometimes a regular expression is not possible and we can instead supply a list of gene IDs or symbols representing mitochondrial genes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">find_mitochondrial_genes</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">genes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;geneA&#39;</span><span class="p">,</span><span class="s1">&#39;geneB&#39;</span><span class="p">,</span><span class="s1">&#39;geneC&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-simple-filters">
<h4>Applying simple filters<a class="headerlink" href="#applying-simple-filters" title="Permalink to this headline">¶</a></h4>
<p>Simple filters refers to applying a strict minimum cutoff on the number of expressed genes per cell and the total read depth per cell. Simple filters are usually effective in removing low quality cells and uninformative genes. If your data come from Drop-seq, 10X, etc, requiring at least 1000 uniquely mapped reads per cell is often sufficient:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">simple_filter</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">minreads</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">minexpgenes</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If your protocol is applying full-length mRNA sequencing, e.g. SMART-seq2, then your <code class="docutils literal notranslate"><span class="pre">minreads</span></code> threshold should be higher, for example 50000.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="adobo.html#adobo.preproc.simple_filter" title="adobo.preproc.simple_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.preproc.simple_filter()</span></code></a> also has a <cite>maxreads</cite> parameter, which can be used to remove cells with an upper read count limit (perhaps useful for limiting doublets). However, this parameter is not set by default.</p>
</div>
<p>It is also desirable to remove genes with an expression signal in very few cells; such genes may contribute more noise than information. The <code class="docutils literal notranslate"><span class="pre">minexpgenes</span></code> parameter can be used to control how genes are filtered out. If you wish to not remove any genes at all, simply set it to zero:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">simple_filter</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">minreads</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">minexpgenes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Setting <code class="docutils literal notranslate"><span class="pre">minexpgenes</span></code> to a fraction indicates that at least that fraction of cells must express any gene. If <code class="docutils literal notranslate"><span class="pre">minexpgenes</span></code> is an integer it refers to the absolute number of cells that at minimum must express the gene for the gene not to be filtered out.</p>
<p>To reset all simple filters to original:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp</span><span class="o">.</span><span class="n">reset_filters</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="dynamic-detection-of-low-quality-cells">
<h4>Dynamic detection of low quality cells<a class="headerlink" href="#dynamic-detection-of-low-quality-cells" title="Permalink to this headline">¶</a></h4>
<p>A more sophisticated approach to detection of low quality cells is to use the function <a class="reference internal" href="adobo.html#adobo.preproc.find_low_quality_cells" title="adobo.preproc.find_low_quality_cells"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.preproc.find_low_quality_cells()</span></code></a>, which uses <a class="reference external" href="https://en.wikipedia.org/wiki/Mahalanobis_distance">Mahalanobis distance</a> to identify bad cells from five quality metrics.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code class="docutils literal notranslate"><span class="pre">find_low_quality_cells</span></code> requires that there are ERCC spikes in your data.</p>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">rRNA_genes</span></code> should either be a string containing the full path to a file on disk contaiing genes that are rRNA genes (the file should have one gene per line). <code class="docutils literal notranslate"><span class="pre">rRNA_genes</span></code> can also be a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code> object with gene symbols.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">find_low_quality_cells</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">rRNA_genes</span><span class="o">=</span><span class="n">rRNA</span><span class="p">)</span>
</pre></div>
</div>
<p>Like all adobo functions, <code class="docutils literal notranslate"><span class="pre">find_low_quality_cells</span></code> modifies the passed object. However, <code class="docutils literal notranslate"><span class="pre">find_low_quality_cells</span></code> also returns a list of cells that are classified as low quality; to prevent such behavior simply assign the return to a variable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">low_q_cells</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">find_low_quality_cells</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">rRNA_genes</span><span class="o">=</span><span class="n">rRNA</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="imputation-of-dropouts">
<h4>Imputation of dropouts<a class="headerlink" href="#imputation-of-dropouts" title="Permalink to this headline">¶</a></h4>
<p>“Dropouts” are artifacts caused by the low amounts of mRNA in single cells, causing expressed genes to become undetected in the expression data. Droplet-based protocols tend to have a greater number of dropouts. Several statistical procedures have been developed to impute missing expression values. adobo implements the method introduced by Li <em>et al</em> <a class="reference internal" href="#li2018" id="id2">[2]</a>. The original paper describes the theory; briefly, model parameters are estimated using the Gamma distribution, then it uses Elastic net regularization to fit a linear model, which is used to predict expression values of genes with zero expression. adobo’s imputation function is <a class="reference internal" href="adobo.html#adobo.preproc.impute" title="adobo.preproc.impute"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.preproc.impute()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">preproc</span><span class="o">.</span><span class="n">impute</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">filtered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nworkers</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">filtered</span></code> is used to indicate if imputation should run on the quality-filtered data or on the complete raw read count matrix (default is to run on the filtered). Parallelization is achieved using Python’s <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> module. The parameter <code class="docutils literal notranslate"><span class="pre">nworkers</span></code> can be used to set the number of worker processes, which can be ‘auto’ to autodetect this (although due to Python’s <a class="reference external" href="https://www.dabeaz.com/python/UnderstandingGIL.pdf">Global Interpreter Lock</a> the number of workers should not be higher than the number of physical cores). Imputed data are stored in <a class="reference internal" href="adobo.html#adobo.data.dataset.imp_count_data" title="adobo.data.dataset.imp_count_data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.imp_count_data</span></code></a>. If you have a low number of cells (&lt;1000), set the cluster resolution parameter to something low, for example <code class="docutils literal notranslate"><span class="pre">res=0.1</span></code>. Finally, to use the imputed data, it must first be normalized:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">normalize</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">use_imputed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Runtime varies depending on number of physical cores and size of the dataset. Typical runtime for a dataset consisting of ~1000 cells using 10 cores is 15 min.</p>
</div>
</div>
</div>
<div class="section" id="normalization">
<h3>Normalization<a class="headerlink" href="#normalization" title="Permalink to this headline">¶</a></h3>
<p>Normalization removes technical and sometimes experimental biases and is always necessary prior to analysis. Because a universal normalization scheme for scRNA-seq data is not available nor recommended, adobo supports several different procedures. The function <a class="reference internal" href="adobo.html#adobo.normalize.norm" title="adobo.normalize.norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.normalize.norm()</span></code></a> can be used to perform the following normalization methods:</p>
<dl class="simple">
<dt><strong>standard</strong></dt><dd><p>Performs a standard normalization by scaling with the total read depth per cell and then multiplying with a scaling factor.</p>
</dd>
<dt><strong>rpkm</strong></dt><dd><p>Normalizes read counts as Reads per kilo base per million mapped reads (RPKM) <a class="reference internal" href="#conesa2016" id="id3">[3]</a>. This method should be used if you need to adjust for gene length, such as in a SMART-Seq2 protocol. To use this procedure you must first prepare a file containing combined exon lengths for genes; the file should contain two columns, <strong>without a header</strong>, and columns separated by one space. The following columns must be present: (1) gene symbols and (2) the sum of exon lengths. The filename is set with the <code class="docutils literal notranslate"><span class="pre">gene_lengths</span></code> parameter, which can also take a vector.</p>
</dd>
<dt><strong>fqn</strong></dt><dd><p>Performs full quantile normalization <a class="reference internal" href="#bolstad2003" id="id4">[4]</a>. FQN was a popular normalization scheme for microarray data. It is not very common in single cell analysis despite having been shown to perform well <a class="reference internal" href="#cole2018" id="id5">[5]</a>. The present implementation does not handle ties well.</p>
</dd>
<dt><strong>clr</strong></dt><dd><p>Centered log ratio normalization. This normalization scheme was introduced in Seurat version 3.0 <a class="reference internal" href="#stuart2018" id="id6">[6]</a>. It is a simple normalization scheme and is an alternative to <code class="docutils literal notranslate"><span class="pre">standard</span></code>.</p>
</dd>
<dt><strong>vsn</strong></dt><dd><p>Variance stabilizing normaliztion based on a negative binomial regression model with regularized parameters. Introduced by <a class="reference internal" href="#hafemeister2019" id="id7">[7]</a> and represents a more sophisticated normalization approach. Appears to marginally improve resolution. Can be used if you have UMI counts.</p>
</dd>
</dl>
<p>All normalization schemes can be followed by log2-transformation by setting <code class="docutils literal notranslate"><span class="pre">log2=True</span></code>, which is the default.</p>
<p>To perform a <code class="docutils literal notranslate"><span class="pre">standard</span></code> normalization followed by <code class="docutils literal notranslate"><span class="pre">log</span></code>-transformation, run:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">normalize</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">normalize</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;clr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The normalized data are stored in the attribute <a class="reference internal" href="adobo.html#adobo.data.dataset.norm_data" title="adobo.data.dataset.norm_data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.norm_data</span></code></a>, which is a dictionary of dictionaries. If we run multiple normalizations they are all stored in the <code class="docutils literal notranslate"><span class="pre">norm_data</span></code> and we can use the name <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter in <a class="reference internal" href="adobo.html#adobo.normalize.norm" title="adobo.normalize.norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.normalize.norm()</span></code></a> to give it a name (default name is the method). We can always call <code class="docutils literal notranslate"><span class="pre">is_normalized()</span></code> to determine if a dataset has been normalized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="o">.</span><span class="n">is_normalized</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you have previously executed <a class="reference internal" href="adobo.html#adobo.preproc.find_ercc" title="adobo.preproc.find_ercc"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.preproc.find_ercc()</span></code></a>, ERCC spikes will be normalized too, and these can be found in <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.norm_ercc</span></code>.</p>
</div>
</div>
<div class="section" id="examining-analysis-history">
<h3>Examining analysis history<a class="headerlink" href="#examining-analysis-history" title="Permalink to this headline">¶</a></h3>
<p>Downstream analyses are performed on the data object. At any time it’s possible to examine what functions have been applied on data object by calling <a class="reference internal" href="adobo.html#adobo.data.dataset.assays" title="adobo.data.dataset.assays"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.data.dataset.assays()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="o">.</span><span class="n">assays</span><span class="p">()</span>
<span class="go">Number of mitochondrial genes found: 0</span>
<span class="go">Number of ERCC spikes found: 92</span>
<span class="go">Normalization method: &lt;not performed yet&gt;</span>
<span class="go">Has HVG discovery been performed? No</span>
</pre></div>
</div>
</div>
<div class="section" id="detection-of-highly-variable-genes">
<h3>Detection of highly variable genes<a class="headerlink" href="#detection-of-highly-variable-genes" title="Permalink to this headline">¶</a></h3>
<p>Many algorithms used in scRNA-seq analysis perform better when used on a subset of measured genes <a class="reference internal" href="#yip2018" id="id8">[8]</a>; the goal of the feature selection step is usually to extract a set highly variable genes (HVG). adobo currently implements the following strategies for HVG discovery:</p>
<dl class="simple">
<dt><strong>seurat</strong></dt><dd><p>The function bins the genes according to average expression, then calculates dispersion for each bin as variance to mean ratio. Within each bin, Z-scores are calculated and returned. Z-scores are ranked and the top 1000 are selected. Input data should be normalized first. This strategy was introduced in Seruat <a class="reference internal" href="#stuart2018" id="id9">[6]</a>, it is simple yet highly effective in identifying HVG.</p>
</dd>
<dt><strong>brennecke</strong></dt><dd><p>Implements the method described in <a class="reference internal" href="#brennecke2013" id="id10">[9]</a>. <code class="docutils literal notranslate"><span class="pre">brennecke</span></code> estimates and fits technical noise using ERCC spikes (technical genes) by fitting a generalized linear model with a gamma function and identity link and the parameterization w=a_1+u+a0. It then uses the chi2 distribution to test the null hypothesis that the squared coefficient of variation does not exceed a certain minimum. False discovery rate (FDR)&lt;0.10 is considered significant.</p>
</dd>
<dt><strong>scran</strong></dt><dd><p>scran fits a polynomial regression model to technical noise by modeling the variance versus mean gene expression relationship of ERCC spikes (the original method used local regression) <a class="reference internal" href="#lun2016" id="id11">[10]</a>. It then decomposes the variance of the biological gene by subtracting the technical variance component and returning the biological variance component.</p>
</dd>
<dt><strong>chen2016</strong></dt><dd><p>This method uses linear regression, subsampling, polynomial fitting and gaussian maximum likelihood estimates to derive a set of HVG <a class="reference internal" href="#chen2016" id="id12">[11]</a>.</p>
</dd>
<dt><strong>mm</strong></dt><dd><p>Selection of HVG by modeling dropout rates using modified Michaelis-Menten kinetics <a class="reference internal" href="#andrews2018" id="id13">[12]</a>. This method calculates dropout rates and mean expression for every gene, then models these with the Michaelis-Menten equation (parameters are estimated with maximum likelihood optimization). The basis for using MM is because most dropouts are caused by failure of the enzyme reverse transcriptase, thus the dropout rate can be modelled with theory developed for enzyme reactions. This implementation works best for libraries sequenced to saturation (i.e. not Drop-seq).</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">hvg</span><span class="o">.</span><span class="n">find_hvg</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;seurat&#39;</span><span class="p">,</span> <span class="n">ngenes</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>The results are stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.hvg</span></code>.</p>
</div>
<div class="section" id="dimensional-reduction">
<h3>Dimensional reduction<a class="headerlink" href="#dimensional-reduction" title="Permalink to this headline">¶</a></h3>
<p>These are techniques to reduce the number of dimensions under consideration. After running these functions, results are stored in the <code class="docutils literal notranslate"><span class="pre">dict</span></code> <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.dr</span></code>.</p>
<div class="section" id="principal-component-analysis-pca">
<h4>Principal Component analysis (PCA)<a class="headerlink" href="#principal-component-analysis-pca" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Principal_component_analysis">PCA</a> decomposition <a class="reference internal" href="#abdi2010" id="id14">[13]</a> of single cell data is for the most part necessary prior to clustering. The reason for this is because the graph construction benefits from a strong signal from each feature. PCA computation in adobo is performed by invoking <a class="reference internal" href="adobo.html#adobo.dr.pca" title="adobo.dr.pca"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.dr.pca()</span></code></a>. Scaling of the data should always be performed before PCA, and this is done by default (although it can be turned off by setting <code class="docutils literal notranslate"><span class="pre">scale=False</span></code>). Two approaches are available for PCA decomposition, and it should not matter much which one is used:</p>
<dl class="simple">
<dt><strong>irlb</strong></dt><dd><p>Computed via truncated singular value decomposition by implicitly restarted Lanczos bidiagonalization <a class="reference internal" href="#baglama2005" id="id15">[14]</a>. <cite>irlb</cite> may be better at handling very large single cell datasets and it is the default.</p>
</dd>
<dt><strong>svd</strong></dt><dd><p>The standard approach to PCA. Computed via singular value decomposition (svd). (More likely to raise <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code>.)</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 75 components are returned by default, may need to be adjusted depending on your dataset</span>
<span class="n">ad</span><span class="o">.</span><span class="n">dr</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;irlb&#39;</span><span class="p">,</span> <span class="n">ncomp</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">dr</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span> <span class="n">ncomp</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PCA components are stored in the dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.dr</span></code> and variable contributions are stored in the dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.dr_gene_contr</span></code>.</p>
</div>
<p>We can now examine the top contributing genes to each PCA component by producing a plot with <a class="reference internal" href="adobo.html#adobo.plotting.pca_contributors" title="adobo.plotting.pca_contributors"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.plotting.pca_contributors()</span></code></a>.</p>
<p>To plot the top 10 contributing genes to the first five components:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">pca_contributors</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/pca_contributors.png" src="_images/pca_contributors.png" />
<p>We can also write the output to a file instead of showing it on the screen:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">pca_contributors</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;top_pca_genes.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default number of components, 75, is often sufficient. However, a more deterministic approach is to generate an elbow plot using <a class="reference internal" href="adobo.html#adobo.plotting.pca_elbow" title="adobo.plotting.pca_elbow"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.plotting.pca_elbow()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">pca_elbow</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="t-distributed-stochastic-neighbor-embedding-t-sne">
<h4>t-Distributed Stochastic Neighbor Embedding (t-SNE)<a class="headerlink" href="#t-distributed-stochastic-neighbor-embedding-t-sne" title="Permalink to this headline">¶</a></h4>
<p>t-SNE <a class="reference internal" href="#vandermaaten2008" id="id16">[15]</a> is a non-linear dimensional reduction technique that optimizes for local distance. It is the <em>de facto</em> dimensional reduction technique used to visualize scRNA-seq data <a class="reference internal" href="#kobak2019" id="id17">[16]</a>. adobo uses the scikit-learn implementation <a class="reference internal" href="#pedregosa2011" id="id18">[17]</a>. The most important parameter is <code class="docutils literal notranslate"><span class="pre">perplexity</span></code> (related to number of nearest neighbors) and it can greatly influence how your plot looks like. Suggested values for <code class="docutils literal notranslate"><span class="pre">perplexity</span></code> lies between 5 and 50, and it is recommened to try higher values for datasets with more cells. Additional parameters (such as early_exaggeration, learning_rate, n_iter, and n_iter_without_progress) do not usually need to be specified but will be passed into <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.manifold.TSNE</span></code>. By default adobo runs t-SNE on the PCA decomposition:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">dr</span><span class="o">.</span><span class="n">tsne</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>The recommended approach is to run t-SNE on PCA components, but it can sometimes be informative to run it on your entire normalized expression matrix (this will take significantly longer time):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">dr</span><span class="o">.</span><span class="n">tsne</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>t-SNE is non-deterministic. Different runs can give different results. To get a more reproducible t-SNE plot consider setting the <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter to any random integer, which will generate reproducible random numbers.</p>
</div>
</div>
<div class="section" id="uniform-manifold-approximation-and-projection-umap">
<h4>Uniform Manifold Approximation and Projection (UMAP)<a class="headerlink" href="#uniform-manifold-approximation-and-projection-umap" title="Permalink to this headline">¶</a></h4>
<p>UMAP <a class="reference internal" href="#mcinnes2018" id="id19">[18]</a> is also used frequently to visualize scRNA-seq data, and it may be better at preserving the global structure of the data:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">dr</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
<div class="section" id="clustering">
<h3>Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h3>
<p>A crucial step in scRNA-seq analysis is to group cells into clusters. Complex datasets consisting of thousands of cells can be reduced to a small number of clusters, which tend to be easier to analyze and interpret.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Clustering is performed in PCA space, therefore PCA components must have been calculated first using <a class="reference internal" href="adobo.html#adobo.dr.pca" title="adobo.dr.pca"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.dr.pca()</span></code></a>.</p>
</div>
<p>In adobo, clustering can be performed with a single line of code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to run leiden with the resolution set to 0.8 (only applicable for leiden)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">clustering</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">clust_alg</span><span class="o">=</span><span class="s1">&#39;leiden&#39;</span><span class="p">)</span>

<span class="c1"># to run walktrap</span>
<span class="n">ad</span><span class="o">.</span><span class="n">clustering</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">clust_alg</span><span class="o">=</span><span class="s1">&#39;walktrap&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will run the necessary steps to cluster your single cell dataset; the cluster membership vector is stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.clusters</span></code>, i.e. represented by an array with the same length as the number of cells after pre-processing. adobo’s default clustering algorithm first builds a Shared Nearest Neighbor graph <a class="reference internal" href="#ertoz2003" id="id20">[19]</a> and then finds communities in this graph using the Leiden algorithm <a class="reference internal" href="#traag2019" id="id21">[20]</a> (default). It may become necessary to change value of the <code class="docutils literal notranslate"><span class="pre">res</span></code> (resolution) parameter to find the optimal clustering outcome.</p>
<p>By default <a class="reference internal" href="adobo.html#adobo.clustering.generate" title="adobo.clustering.generate"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.clustering.generate()</span></code></a> will return a <code class="docutils literal notranslate"><span class="pre">dict</span></code> containing cluster sizes (number of cells), use <code class="docutils literal notranslate"><span class="pre">retx=False</span></code> to disable this behavior.</p>
<p>Other community detection algorithms are also supported via the <a class="reference external" href="https://igraph.org/redirect.html">igraph</a> package:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">walktrap</span></code> <a class="reference internal" href="#pons2006" id="id22">[21]</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spinglass</span></code> <a class="reference internal" href="#reichardt2006" id="id23">[22]</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multilevel</span></code> <a class="reference internal" href="#blondel2008" id="id24">[23]</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">infomap</span></code> <a class="reference internal" href="#rosvall2008" id="id25">[24]</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">label_prop</span></code> (label propagation) <a class="reference internal" href="#raghavan2007" id="id26">[25]</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">leading_eigenvector</span></code> (Newman’s leading eigenvector method) <a class="reference internal" href="#newman2006" id="id27">[26]</a></p></li>
</ul>
<p>Various parameters of the these algorithms can be changed in <a class="reference internal" href="adobo.html#adobo.clustering.generate" title="adobo.clustering.generate"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.clustering.generate()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">spinglass</span></code> does not scale well on large datasets <a class="reference internal" href="#yang2016" id="id28">[27]</a>.</p>
</div>
</div>
<div class="section" id="clustering-visualization">
<h3>Clustering visualization<a class="headerlink" href="#clustering-visualization" title="Permalink to this headline">¶</a></h3>
<p>Visualization of cells in 2d space is performed with the function <a class="reference internal" href="adobo.html#adobo.plotting.cell_viz" title="adobo.plotting.cell_viz"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.plotting.cell_viz()</span></code></a>. Before running <code class="docutils literal notranslate"><span class="pre">cell_viz</span></code>, the appropriate reduction functions must have been invoked (t-SNE or UMAP; see above). <code class="docutils literal notranslate"><span class="pre">cell_viz</span></code> can plot custom meta data, gene expression, and clustering outcomes. Three parameters specified as tuples control what to plot:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clustering</span></code></dt><dd><p>Default is ‘leiden’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata</span></code></dt><dd><p>Specify variable(s) listed as meta data in <a class="reference internal" href="adobo.html#adobo.data.dataset.meta_cells" title="adobo.data.dataset.meta_cells"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.meta_cells</span></code></a> (added via <a class="reference internal" href="adobo.html#adobo.data.dataset.add_meta_data" title="adobo.data.dataset.add_meta_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">adobo.data.dataset.add_meta_data()</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">genes</span></code></dt><dd><p>Specify any gene symbol(s).</p>
</dd>
</dl>
<p>The above parameters can be mixed and will in such cases generate one subplot for every specified variable. The <code class="docutils literal notranslate"><span class="pre">ncols</span></code> parameter can be used to set the number of columns in the plot (default is 2).</p>
<p>Examples:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># tsne</span>
<span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">cell_viz</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;tsne&#39;</span><span class="p">,</span> <span class="n">clustering</span><span class="o">=</span><span class="s1">&#39;leiden&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="s1">&#39;detected_genes&#39;</span><span class="p">)</span>

<span class="c1"># plots &#39;leiden&#39; by default</span>
<span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">cell_viz</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;umap&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Plotting mitochondrial gene expression:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">cell_viz</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;tsne&#39;</span><span class="p">,</span> <span class="n">meta_data</span><span class="o">=</span><span class="s1">&#39;mito_perc&#39;</span><span class="p">,</span> <span class="n">clustering</span><span class="o">=</span><span class="p">(),</span> <span class="n">genes</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<img alt="_images/mito_perc_tsne.png" class="align-center" src="_images/mito_perc_tsne.png" />
</div>
<div class="section" id="cell-cycle-prediction">
<h3>Cell cycle prediction<a class="headerlink" href="#cell-cycle-prediction" title="Permalink to this headline">¶</a></h3>
<p>An extreme simplification of the cell cycle is shown below (figure from Wikipedia). It is often useful to get an understanding of cell cycle states in a new data set, and it boils down to predicting one of three cell cycle states for every cell: G1, S and G2M.</p>
<img alt="Source: Wikipedia" class="align-center" src="_images/cell_cycle_wikipedia.png" />
<p>adobo contains a machine learning classifier based on the sklearn implementation of <a class="reference external" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">Stochastic Gradient Descent</a>. The classifier is trained on mouse embryonic stem cells (n=288 cells) <a class="reference internal" href="#buettner2015" id="id29">[28]</a>. The original data can be retrieved from <a class="reference external" href="https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2805/">here</a>. Cell cycle classification is performed by calling two functions:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># trains the classifier</span>
<span class="n">clf</span><span class="p">,</span> <span class="n">tr_features</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">bio</span><span class="o">.</span><span class="n">cell_cycle_train</span><span class="p">()</span>

<span class="c1"># performs the actual classification of cells in your data</span>
<span class="n">ad</span><span class="o">.</span><span class="n">bio</span><span class="o">.</span><span class="n">cell_cycle_predict</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">tr_features</span><span class="p">)</span>
</pre></div>
</div>
<p>Classification is stored in the attribute <a class="reference internal" href="adobo.html#adobo.data.dataset.meta_cells" title="adobo.data.dataset.meta_cells"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.meta_cells</span></code></a> in a column <cite>cell_cycle</cite>. The current design does not support prediction scores, although this can easily be changed by changing the <a class="reference external" href="https://scikit-learn.org/stable/modules/sgd.html">loss parameter</a>.</p>
<p>We can visualize the results:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">cell_viz</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="s1">&#39;cell_cycle&#39;</span><span class="p">,</span> <span class="n">clustering</span><span class="o">=</span><span class="p">(),</span> <span class="n">genes</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Prediction is only valid on mouse data since the classifier is trained on mouse data. Make sure your gene expression contains Ensembl gene identifiers in one of the following two formats: ENSEMBL; GENESYMBOL_ENSEMBL.</p>
</div>
</div>
<div class="section" id="cell-type-prediction">
<h3>Cell type prediction<a class="headerlink" href="#cell-type-prediction" title="Permalink to this headline">¶</a></h3>
<p>Runs marker-based cell type prediction. The smallest predicted unit is a cell cluster. Cell type prediction works on mouse and human data. Gene symbols must be ued in your data. The <code class="docutils literal notranslate"><span class="pre">min_cluster_size</span></code> parameter specifies which clusters to ignore (i.e. clusters with fewer cells than this are ignored). Will run on all normalizations and clusterings as default (or specify which one with <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">clustering</span></code>).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ad</span><span class="o">.</span><span class="n">bio</span><span class="o">.</span><span class="n">predict_cell_type</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The output is stored in the attribute <a class="reference internal" href="adobo.html#adobo.data.dataset.norm_data" title="adobo.data.dataset.norm_data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">adobo.data.dataset.norm_data</span></code></a>.</p>
</div>
<div class="section" id="indices-and-tables">
<h3>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
</ul>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p id="bibtex-bibliography-index-0"><dl class="citation">
<dt class="label" id="jiang2011"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Lichun Jiang, Felix Schlesinger, Carrie A. Davis, Yu Zhang, Renhua Li, Marc Salit, Thomas R. Gingeras, and Brian Oliver. Synthetic spike-in standards for RNA-seq experiments. <em>Genome Research</em>, 21(9):1543–1551, September 2011. <a class="reference external" href="https://doi.org/10.1101/gr.121095.111">doi:10.1101/gr.121095.111</a>.</p>
</dd>
<dt class="label" id="li2018"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Wei Vivian Li and Jingyi Jessica Li. An accurate and robust imputation method scImpute for single-cell RNA-seq data. <em>Nature Communications</em>, 9(1):997, March 2018. <a class="reference external" href="https://doi.org/10.1038/s41467-018-03405-7">doi:10.1038/s41467-018-03405-7</a>.</p>
</dd>
<dt class="label" id="conesa2016"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Ana Conesa, Pedro Madrigal, Sonia Tarazona, David Gomez-Cabrero, Alejandra Cervera, Andrew McPherson, Michał Wojciech Szcześniak, Daniel J. Gaffney, Laura L. Elo, Xuegong Zhang, and Ali Mortazavi. A survey of best practices for RNA-seq data analysis. <em>Genome Biology</em>, 17(1):13, January 2016. <a class="reference external" href="https://doi.org/10.1186/s13059-016-0881-8">doi:10.1186/s13059-016-0881-8</a>.</p>
</dd>
<dt class="label" id="bolstad2003"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>B.M. Bolstad, R.A Irizarry, M. Åstrand, and T.P. Speed. A comparison of normalization methods for high density oligonucleotide array data based on variance and bias. <em>Bioinformatics</em>, 19(2):185–193, 01 2003. <a class="reference external" href="https://doi.org/10.1093/bioinformatics/19.2.185">doi:10.1093/bioinformatics/19.2.185</a>.</p>
</dd>
<dt class="label" id="cole2018"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Michael B. Cole, Davide Risso, Allon Wagner, David DeTomaso, John Ngai, Elizabeth Purdom, Sandrine Dudoit, and Nir Yosef. Performance assessment and selection of normalization procedures for single-cell rna-seq. <em>bioRxiv</em>, 2018. <a class="reference external" href="https://doi.org/10.1101/235382">doi:10.1101/235382</a>.</p>
</dd>
<dt class="label" id="stuart2018"><span class="brackets">6</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>Tim Stuart, Andrew Butler, Paul Hoffman, Christoph Hafemeister, Efthymia Papalexi, William M Mauck III, Marlon Stoeckius, Peter Smibert, and Rahul Satija. Comprehensive integration of single cell data. <em>bioRxiv</em>, 2018. <a class="reference external" href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>.</p>
</dd>
<dt class="label" id="hafemeister2019"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>Christoph Hafemeister and Rahul Satija. Normalization and variance stabilization of single-cell rna-seq data using regularized negative binomial regression. <em>bioRxiv</em>, 2019. <a class="reference external" href="https://doi.org/10.1101/576827">doi:10.1101/576827</a>.</p>
</dd>
<dt class="label" id="yip2018"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>Shun H Yip, Pak Chung Sham, and Junwen Wang. Evaluation of tools for highly variable gene discovery from single-cell RNA-seq data. <em>Briefings in Bioinformatics</em>, 02 2018. <a class="reference external" href="https://doi.org/10.1093/bib/bby011">doi:10.1093/bib/bby011</a>.</p>
</dd>
<dt class="label" id="brennecke2013"><span class="brackets"><a class="fn-backref" href="#id10">9</a></span></dt>
<dd><p>Philip Brennecke, Simon Anders, Jong Kyoung Kim, Aleksandra A Kołodziejczyk, Xiuwei Zhang, Valentina Proserpio, Bianka Baying, Vladimir Benes, Sarah A Teichmann, John C Marioni, and Marcus G Heisler. Accounting for technical noise in single-cell RNA-seq experiments. <em>Nature Methods</em>, 10:1093, September 2013. URL: <a class="reference external" href="https://doi.org/10.1038/nmeth.2645">https://doi.org/10.1038/nmeth.2645</a>.</p>
</dd>
<dt class="label" id="lun2016"><span class="brackets"><a class="fn-backref" href="#id11">10</a></span></dt>
<dd><p>Aaron T. L. Lun, Davis J. McCarthy, and John C. Marioni. A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor. <em>F1000Research</em>, 5:2122, 2016. <a class="reference external" href="https://doi.org/10.12688/f1000research.9501.2">doi:10.12688/f1000research.9501.2</a>.</p>
</dd>
<dt class="label" id="chen2016"><span class="brackets"><a class="fn-backref" href="#id12">11</a></span></dt>
<dd><p>Hung-I Harry Chen, Yufang Jin, Yufei Huang, and Yidong Chen. Detection of high variability in gene expression from single-cell RNA-seq profiling. <em>BMC Genomics</em>, 17(7):508, August 2016. <a class="reference external" href="https://doi.org/10.1186/s12864-016-2897-6">doi:10.1186/s12864-016-2897-6</a>.</p>
</dd>
<dt class="label" id="andrews2018"><span class="brackets"><a class="fn-backref" href="#id13">12</a></span></dt>
<dd><p>Tallulah S Andrews and Martin Hemberg. M3Drop: dropout-based feature selection for scRNASeq. <em>Bioinformatics</em>, 35(16):2865–2867, 12 2018. <a class="reference external" href="https://doi.org/10.1093/bioinformatics/bty1044">doi:10.1093/bioinformatics/bty1044</a>.</p>
</dd>
<dt class="label" id="abdi2010"><span class="brackets"><a class="fn-backref" href="#id14">13</a></span></dt>
<dd><p>Hervé Abdi and Lynne J. Williams. Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2(4):433–459, 2010. <a class="reference external" href="https://doi.org/10.1002/wics.101">doi:10.1002/wics.101</a>.</p>
</dd>
<dt class="label" id="baglama2005"><span class="brackets"><a class="fn-backref" href="#id15">14</a></span></dt>
<dd><p>James Baglama and Lothar Reichel. Augmented implicitly restarted lanczos bidiagonalization methods. <em>SIAM J. Sci. Comput.</em>, 27(1):19–42, July 2005. <a class="reference external" href="https://doi.org/10.1137/04060593X">doi:10.1137/04060593X</a>.</p>
</dd>
<dt class="label" id="vandermaaten2008"><span class="brackets"><a class="fn-backref" href="#id16">15</a></span></dt>
<dd><p>Laurens van der Maaten and Geoffrey Hinton. Visualizing data using t-SNE. <em>Journal of Machine Learning Research</em>, 9:2579–2605, 2008.</p>
</dd>
<dt class="label" id="kobak2019"><span class="brackets"><a class="fn-backref" href="#id17">16</a></span></dt>
<dd><p>Dmitry Kobak and Philipp Berens. The art of using t-sne for single-cell transcriptomics. <em>bioRxiv</em>, 2019. <a class="reference external" href="https://doi.org/10.1101/453449">doi:10.1101/453449</a>.</p>
</dd>
<dt class="label" id="pedregosa2011"><span class="brackets"><a class="fn-backref" href="#id18">17</a></span></dt>
<dd><p>F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. Scikit-learn: machine learning in Python. <em>Journal of Machine Learning Research</em>, 12:2825–2830, 2011.</p>
</dd>
<dt class="label" id="mcinnes2018"><span class="brackets"><a class="fn-backref" href="#id19">18</a></span></dt>
<dd><p>Leland McInnes, John Healy, and James Melville. UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. <em>arXiv e-prints</em>, pages arXiv:1802.03426, Feb 2018. <a class="reference external" href="https://arxiv.org/abs/1802.03426">arXiv:1802.03426</a>.</p>
</dd>
<dt class="label" id="ertoz2003"><span class="brackets"><a class="fn-backref" href="#id20">19</a></span></dt>
<dd><p>Levent Ertöz, Michael Steinbach, and Vipin Kumar. Finding clusters of different sizes, shapes, and densities in noisy, high dimensional data. In <em>in Proceedings of Second SIAM International Conference on Data Mining</em>. 2003.</p>
</dd>
<dt class="label" id="traag2019"><span class="brackets"><a class="fn-backref" href="#id21">20</a></span></dt>
<dd><p>V. A. Traag, L. Waltman, and N. J. van Eck. From Louvain to Leiden: guaranteeing well-connected communities. <em>Scientific Reports</em>, 9(1):5233, March 2019. <a class="reference external" href="https://doi.org/10.1038/s41598-019-41695-z">doi:10.1038/s41598-019-41695-z</a>.</p>
</dd>
<dt class="label" id="pons2006"><span class="brackets"><a class="fn-backref" href="#id22">21</a></span></dt>
<dd><p>Pascal Pons and Matthieu Latapy. Computing Communities in Large Networks Using Random Walks. <em>Journal of Graph Algorithms and Applications</em>, 2006.</p>
</dd>
<dt class="label" id="reichardt2006"><span class="brackets"><a class="fn-backref" href="#id23">22</a></span></dt>
<dd><p>Joerg Reichardt and Stefan Bornholdt. Statistical mechanics of community detection. <em>Physical Review E</em>, 74:016110, 2006.</p>
</dd>
<dt class="label" id="blondel2008"><span class="brackets"><a class="fn-backref" href="#id24">23</a></span></dt>
<dd><p>Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. Fast unfolding of communities in large networks. <em>Journal of Statistical Mechanics: Theory and Experiment</em>, 2008(10):10008, Oct 2008. <a class="reference external" href="https://doi.org/10.1088/1742-5468/2008/10/P10008">doi:10.1088/1742-5468/2008/10/P10008</a>.</p>
</dd>
<dt class="label" id="rosvall2008"><span class="brackets"><a class="fn-backref" href="#id25">24</a></span></dt>
<dd><p>Martin Rosvall and Carl T. Bergstrom. Maps of random walks on complex networks reveal community structure. <em>Proceedings of the National Academy of Sciences</em>, 105(4):1118–1123, 2008. <a class="reference external" href="https://doi.org/10.1073/pnas.0706851105">doi:10.1073/pnas.0706851105</a>.</p>
</dd>
<dt class="label" id="raghavan2007"><span class="brackets"><a class="fn-backref" href="#id26">25</a></span></dt>
<dd><p>Usha Nandini Raghavan, Réka Albert, and Soundar Kumara. Near linear time algorithm to detect community structures in large-scale networks. <em>Phys. Rev. E</em>, 76:036106, Sep 2007. <a class="reference external" href="https://doi.org/10.1103/PhysRevE.76.036106">doi:10.1103/PhysRevE.76.036106</a>.</p>
</dd>
<dt class="label" id="newman2006"><span class="brackets"><a class="fn-backref" href="#id27">26</a></span></dt>
<dd><p>M. E. J. Newman. Finding community structure in networks using the eigenvectors of matrices. <em>Phys. Rev. E</em>, 74:036104, Sep 2006. <a class="reference external" href="https://doi.org/10.1103/PhysRevE.74.036104">doi:10.1103/PhysRevE.74.036104</a>.</p>
</dd>
<dt class="label" id="yang2016"><span class="brackets"><a class="fn-backref" href="#id28">27</a></span></dt>
<dd><p>Zhao Yang, René Algesheimer, and Claudio J. Tessone. A Comparative Analysis of Community Detection Algorithms on Artificial Networks. <em>Scientific Reports</em>, 6:30750, August 2016. URL: <a class="reference external" href="https://doi.org/10.1038/srep30750">https://doi.org/10.1038/srep30750</a>.</p>
</dd>
<dt class="label" id="buettner2015"><span class="brackets"><a class="fn-backref" href="#id29">28</a></span></dt>
<dd><p>Florian Buettner, Kedar N Natarajan, F Paolo Casale, Valentina Proserpio, Antonio Scialdone, Fabian J Theis, Sarah A Teichmann, John C Marioni, and Oliver Stegle. Computational analysis of cell-to-cell heterogeneity in single-cell RNA-sequencing data reveals hidden subpopulations of cells. <em>Nature Biotechnology</em>, 33:155, January 2015.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">adobo  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Oscar Franzen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>